/*
链式队列（带头结点）
*/
#include <iostream>
using namespace std;

typedef int ElementType; 
typedef struct LinkNode{
	ElementType data;
	struct LinkNode* next;
}LinkNode;
typedef struct LinkQueue {
	LinkNode* front, * rear;
}LinkQueue;

//初始化链式队列
LinkQueue initLinkQueue() {
	LinkQueue q;
	q.front = q.rear = new LinkNode;
	q.front->next = NULL;
	return q;
}

//判断队列是否为空
bool judgeLinkQueueEmpty(LinkQueue q) {
	return q.front == q.rear;
}

//入队尾插
bool enterLinkQueue(LinkQueue &q,ElementType data) {
	LinkNode* s = new LinkNode;
	if (!s) {
		cout << "内存满了" << endl;
		return false;
	}
	s->data = data;
	s->next = NULL;
	q.rear->next = s;
	q.rear = s;
	return true;
}

//出队头出
bool quitLinkQueue(LinkQueue &q,ElementType &data) {
	bool isEmpty = judgeLinkQueueEmpty(q);
	if (isEmpty) {
		cout << "队列为空" << endl;
		return false;
	}
	LinkNode* t = q.front->next;
	q.front->next = t->next;
	if (t == q.rear) {
		q.rear = q.front;
	}
	data = t->data;
	free(t);
	return true;
}


int main() {
	ElementType temp;
	LinkQueue q = initLinkQueue();
	bool isEmpty = judgeLinkQueueEmpty(q);
	for (size_t i = 0; i < 5; i++)
	{
		enterLinkQueue(q, i);
	}
	 isEmpty = judgeLinkQueueEmpty(q);
	for (size_t i = 0; i < 7; i++)
	{
		quitLinkQueue(q,temp);
	}
	 isEmpty = judgeLinkQueueEmpty(q);
	return 0;
}
